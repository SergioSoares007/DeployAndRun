<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>REST vs. gRPC Part2 | DeployAndRun</title><meta name=keywords content="REST,gRPC"><meta name=description content="REST vs. gRPC: Understanding the Differences and Choosing the Right Protocol"><meta name=author content="Me"><link rel=canonical href=https://canonical.url/to/page><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.36819bea596090d8b48cf10d9831382996197aa7e4fc86f792f7c08c9ca4d23b.css integrity="sha256-NoGb6llgkNi0jPENmDE4KZYZeqfk/Ib3kvfAjJyk0js=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/json href=http://localhost:1313/posts/post14/index.json><link rel=alternate hreflang=en href=http://localhost:1313/posts/post14/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="http://localhost:1313/posts/post14/"><meta property="og:site_name" content="DeployAndRun"><meta property="og:title" content="REST vs. gRPC Part2"><meta property="og:description" content="REST vs. gRPC: Understanding the Differences and Choosing the Right Protocol"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-06T23:00:03+00:00"><meta property="article:modified_time" content="2025-04-06T23:00:03+00:00"><meta property="article:tag" content="REST"><meta property="article:tag" content="GRPC"><meta property="og:image" content="http://localhost:1313/%3Cimage%20path/url%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Cimage%20path/url%3E"><meta name=twitter:title content="REST vs. gRPC Part2"><meta name=twitter:description content="REST vs. gRPC: Understanding the Differences and Choosing the Right Protocol"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"REST vs. gRPC Part2","item":"http://localhost:1313/posts/post14/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"REST vs. gRPC Part2","name":"REST vs. gRPC Part2","description":"REST vs. gRPC: Understanding the Differences and Choosing the Right Protocol","keywords":["REST","gRPC"],"articleBody":"REST vs gRPC: The Pragmatic, Developer-Friendly Guide TL;DR\nREST is universal, human-friendly, cacheable, and ideal for public APIs and browser clients. It uses HTTP semantics with resource-oriented design and JSON by default. gRPC is fast, strongly typed, and streaming-friendly—great for internal microservices and low-latency mobile/IoT. It uses HTTP/2 (or HTTP/3 in some stacks) and Protocol Buffers (Protobuf). Use REST for broad reach, compatibility, and simple CRUD; use gRPC for high-throughput, low-latency, streaming, or strongly typed interfaces across polyglot services. Hybrid patterns—REST for public, gRPC internally—often deliver the best of both worlds. Contents\nWhat are REST and gRPC? Mental Models: Resources vs RPC Transports: HTTP/1.1, HTTP/2, HTTP/3 Data Formats: JSON vs Protobuf (and JSON with gRPC) Streaming, Real-time, and Backpressure API Design: URLs vs RPC methods, versioning, pagination Errors, Retries, and Timeouts Caching and CDNs Security and Auth Tooling and Developer Experience Observability: Logs, Metrics, Traces Platform Support: Browsers, Mobile, Cloud, and Meshes Performance \u0026 Cost Considerations Migration and Hybrid Architectures Best Practices and Common Pitfalls Decision Checklist FAQs Summary What are REST and gRPC?\nREST (Representational State Transfer) is an architectural style layered onto HTTP. You expose resources (users, orders, posts) with URLs and standard HTTP methods (GET, POST, PUT, PATCH, DELETE). Responses are typically JSON. REST’s superpower is universality: it works practically everywhere, especially on the web. gRPC is an RPC framework created at Google. It uses Protocol Buffers (but can support other encodings) with an Interface Definition Language (IDL) to generate client and server code. It runs over HTTP/2 (and in several stacks HTTP/3) and supports streaming in all directions. Its superpower is efficiency, strong typing, and first-class streaming. Mental Models: Resources vs RPC\nREST: Resource-oriented\nIdentify nouns/resources (e.g., /users/123/orders). Use HTTP verbs to express actions (GET to read, POST to create). Embrace HTTP semantics (status codes, caching, content negotiation). Pros: self-descriptive, cache-friendly, easy for browsers, widely understood. Trade-offs: mapping complex workflows or streaming can be awkward. gRPC: Procedure/method-oriented\nDefine services and methods (UserService.GetUser, OrderService.CreateOrder). Strongly typed requests/responses using Protobuf schemas. Unary and streaming calls as first-class citizens. Pros: compact, fast, codegen-powered DX, great for microservices and streaming. Trade-offs: weaker browser-native support, tooling is different, caching/CDN less natural. Transports: HTTP/1.1, HTTP/2, HTTP/3\nREST\nTypically HTTP/1.1, but also works over HTTP/2 and HTTP/3 transparently via standard web servers/CDNs. Benefits from HTTP/2 multiplexing and header compression where available. Easily goes through proxies, gateways, and CDNs. gRPC\nStandard gRPC uses HTTP/2 for multiplexed, bidirectional streams. Many ecosystems now support gRPC over HTTP/3 (QUIC), improving head-of-line blocking and mobility; check your language/runtime’s current support. Not natively supported by browsers due to streaming and header constraints; grpc-web bridges this gap via a proxy and HTTP/1.1/2 friendly semantics. Data Formats: JSON vs Protobuf (and JSON with gRPC)\nREST payloads\nCommonly JSON; also XML, YAML, or binary for special cases. Human-readable; excellent for debugging and public API docs. Larger on-the-wire size vs Protobuf; more CPU to parse at scale. gRPC payloads\nDefault is Protobuf: compact binary encoding, fast encoding/decoding. Strong schemas with backward/forward-compatible design (field numbers, optional fields, oneof). Unknown fields are usually ignored on parse—great for gradual rollout. JSON in gRPC?\ngRPC can be used with JSON via transcoding gateways (e.g., Envoy + grpc-json-transcoder or grpc-gateway). This lets you expose REST/JSON endpoints that internally call gRPC. Some stacks support gRPC-JSON directly for ease of interop at the edge. Streaming, Real-time, and Backpressure\ngRPC has first-class streaming: Unary: single request -\u003e single response (most REST-like). Server streaming: single request -\u003e stream of responses (e.g., logs, events). Client streaming: stream of requests -\u003e single response (e.g., batch upload). Bidirectional streaming: both sides stream concurrently (e.g., chat, telemetry, ML inference pipelines). REST equivalents: Server-sent events (SSE): server -\u003e client stream over HTTP. Easy in browsers; unidirectional. WebSockets: full-duplex channel over a single TCP; great for real-time, but not REST semantics and requires different infra and protocols. Chunked transfer and long polling: workarounds, but not as clean as gRPC streaming. Backpressure and flow control:\ngRPC/HTTP/2 provide built-in flow control and framing to handle backpressure more gracefully. REST with SSE or WebSockets requires you to design your own flow control patterns and congestion/backpressure strategies. API Design: URLs vs RPC methods, versioning, pagination\nREST design tips\nUse plural nouns and resource hierarchies: GET /users/{id}/orders. HTTP status codes (200, 201, 204, 400, 401, 403, 404, 409, 422, 429, 500). Partial updates with PATCH and JSON Patch/JSON Merge Patch. Versioning strategies: URI (/v1/), header-based, or default + backward-compatible evolution. Pagination: limit/offset, or cursor/page_token. Cursor is preferred at scale. Conditional requests: ETag/If-None-Match for concurrency and caching. Filtering/sorting: query params (e.g., ?status=active\u0026sort=-created_at). gRPC design tips\nServices and RPCs should be business-action oriented but cohesive (UserService, OrderService). Design request/response messages explicitly; include page_size and page_token in requests, and next_page_token in responses. Use field numbers carefully; never reuse removed numbers; prefer additive changes (new optional fields). Represent partial updates with FieldMask where applicable. Consider error detail messages using google.rpc.Status and google.rpc.ErrorInfo for structured errors. Versioning: package name and service name (my.app.v1) to separate new versions while allowing coexistence. Code examples\nREST (curl + Node.js/Express)\n# Create a user curl -X POST https://api.example.com/v1/users \\ -H 'Content-Type: application/json' \\ -d '{\"email\":\"dev@example.com\",\"name\":\"Doe\"}' // app.js (Express) const express = require('express'); const app = express(); app.use(express.json()); app.get('/v1/users/:id', async (req, res) =\u003e { const user = await db.getUser(req.params.id); if (!user) return res.status(404).json({ error: 'Not found' }); res.json(user); }); app.post('/v1/users', async (req, res) =\u003e { const user = await db.createUser(req.body); res.status(201).json(user); }); app.listen(3000); gRPC (proto + Go server + grpcurl)\n// user.proto syntax = \"proto3\"; package example.user.v1; option go_package = \"example.com/user/gen;userv1\"; service UserService { rpc GetUser(GetUserRequest) returns (GetUserResponse) {} rpc CreateUser(CreateUserRequest) returns (CreateUserResponse) {} rpc StreamUsers(StreamUsersRequest) returns (stream GetUserResponse) {} } message GetUserRequest { string id = 1; } message GetUserResponse { string id = 1; string email = 2; string name = 3; } message CreateUserRequest { string email = 1; string name = 2; } message CreateUserResponse { string id = 1; } message StreamUsersRequest { int32 page_size = 1; string page_token = 2; } // server.go (Go gRPC) type userServer struct { userv1.UnimplementedUserServiceServer } func (s *userServer) GetUser(ctx context.Context, req *userv1.GetUserRequest) (*userv1.GetUserResponse, error) { u, err := dbGet(req.Id) if err == sql.ErrNoRows { return nil, status.Error(codes.NotFound, \"user not found\") } else if err != nil { return nil, status.Error(codes.Internal, \"db error\") } return \u0026userv1.GetUserResponse{Id: u.ID, Email: u.Email, Name: u.Name}, nil } # Call gRPC with grpcurl (no client code needed) grpcurl -plaintext localhost:50051 example.user.v1.UserService/GetUser \\ -d '{\"id\":\"123\"}' Errors, Retries, and Timeouts\nREST error model\nHTTP status codes convey coarse categories. Include a JSON body with machine-readable codes and human-readable messages. Typical mapping: 400 Bad Request: validation errors 401 Unauthorized: auth required 403 Forbidden: not allowed 404 Not Found 409 Conflict: duplicate or state conflict 422 Unprocessable: semantic validation failed 429 Too Many Requests: rate limiting 500/502/503/504: server/network errors Retries: safe and idempotent methods (GET, HEAD) can be retried. POST requires idempotency keys if retried. gRPC error model\ngRPC status codes (codes.*) and rich error details through google.rpc.Status: InvalidArgument, NotFound, AlreadyExists, Unauthenticated, PermissionDenied ResourceExhausted (rate limit), FailedPrecondition, Aborted (conflicts), OutOfRange Unimplemented, Internal, Unavailable (retryable), DeadlineExceeded Retries: baked into gRPC service config and proxies (e.g., Envoy) with per-method policies and idempotency awareness. Deadlines and cancellation are first-class: clients set deadlines; servers can observe ctx.Done() to stop work. Cancellation propagates over the wire. Practical mapping between models (guidance):\ngRPC NotFound ↔ HTTP 404 InvalidArgument ↔ 400 AlreadyExists ↔ 409 ResourceExhausted ↔ 429 Unauthenticated ↔ 401; PermissionDenied ↔ 403 Unavailable ↔ 503; DeadlineExceeded ↔ 504 Internal ↔ 500; Unimplemented ↔ 501 Aborted/FailedPrecondition ↔ 409/400 depending on semantics Timeouts and deadlines:\nREST: use server-side timeouts and client request timeouts; communicate Retry-After when applicable. gRPC: clients set explicit deadlines per call; servers should respect them and return DeadlineExceeded when exceeded. Caching and CDNs\nREST\nStrong out-of-the-box support: Cache-Control, ETag/If-None-Match, Last-Modified/If-Modified-Since, Vary. CDNs and browsers understand HTTP semantics; static and dynamic GETs can be cached with fine-grained control. Conditional requests reduce bandwidth and enable optimistic concurrency. gRPC\nProxies generally don’t cache gRPC by default. You can add custom caching (e.g., via Envoy filters, application caches) but it requires deliberate design. For public content and global distribution, REST + CDN is typically the simplest, cheapest path. Security and Auth\nTransport security\nREST: HTTPS (TLS) is standard. mTLS is common in zero-trust/internal environments. gRPC: also uses TLS; mTLS is common within service meshes. HTTP/2 uses ALPN to negotiate h2. AuthN/AuthZ\nREST: OAuth 2.0 and OpenID Connect for delegated access, JWT bearer tokens, API keys for simple cases. CORS for browser access control. gRPC: send tokens via metadata (authorization: Bearer ) or dedicated headers. Integrates with OIDC/JWT, mTLS-based identity, and service meshes for policy (e.g., Istio, Linkerd). Browser specifics: grpc-web uses standard HTTP requests under the hood, so CORS applies. CSRF/Clickjacking\nREST: use same-site cookies, CSRF tokens for cookie-backed auth. gRPC: typically token-based headers; CSRF less of a concern when not using cookies. Tooling and Developer Experience\nREST tools\nSpecification: OpenAPI (Swagger), JSON Schema. Docs/portals: Swagger UI, Redoc, Stoplight. Testing: curl, httpie, Postman, Insomnia, Newman. Mocking/contract tests: Prism, WireMock, Pact. Client generation: openapi-generator, Swagger Codegen. gRPC tools\nSpecification: .proto files (IDL). Code generation for clients/servers in many languages. CLI: grpcurl, evans, ghz (load testing). Ecosystem: Buf (lint/build/breaking-change checks), Prototool, protoc plugins. Gateways: Envoy gRPC-JSON transcoder, grpc-gateway. GUI clients: BloomRPC, Kreya, Insomnia gRPC. Developer ergonomics\nREST: zero-code clients (curl) and easy browser testing. JSON is human-readable. gRPC: strong typing, auto-generated stubs, streaming APIs, better for polyglot microservices. Requires proto discipline and tooling setup. Observability: Logs, Metrics, Traces\nREST\nUse structured logs (method, path, status, duration, request-id). Metrics: request rate, latency, error rates, by endpoint and verb. Tracing: OpenTelemetry instrumentation, propagate traceparent header (W3C Trace Context). Correlation IDs: X-Request-ID or trace context headers. gRPC\nLogs: include method name (Service/Method), peer info, status codes. Metrics: per-method latency, message counts (for streams). Tracing: OpenTelemetry with gRPC interceptors automatically capturing spans. Propagate metadata (e.g., grpc-trace-bin, or W3C headers where supported). Deadlines, retries, and cancellations show up in spans—great for troubleshooting. Platform Support: Browsers, Mobile, Cloud, and Meshes\nBrowsers\nREST: native. CORS handled by server. gRPC: not natively supported due to HTTP/2 and binary framing; use grpc-web via a proxy (Envoy, gRPC-Web) to translate between browser-friendly HTTP and backend gRPC. Mobile\nBoth REST and gRPC work. gRPC’s smaller payloads and multiplexing can save battery and data; REST may be simpler if you also need caching/CDN and offline sync with HTTP caches. Cloud load balancers and gateways\nREST: works with any gateway/CDN (CloudFront, Cloudflare, Fastly, API Gateway). gRPC: widely supported by modern L7 proxies (Envoy, NGINX, HAProxy) and managed LBs on major clouds. Some API gateways now forward gRPC and even support transcoding. Verify feature parity (e.g., retries, H/2 keepalives, connection limits). Service meshes\nBoth REST and gRPC benefit. gRPC + mesh (e.g., Istio/Envoy) unlocks rich policies (mTLS, retries, timeouts) and telemetry with minimal app code. Performance \u0026 Cost Considerations\nLatency and throughput\ngRPC with Protobuf is typically faster to parse and smaller over the wire than REST+JSON, especially at scale and with chatty internal services. HTTP/2 multiplexing reduces head-of-line blocking and connection overhead. With HTTP/3 (QUIC), gRPC can further reduce tail latency on lossy networks. REST benefits from CDNs and caching, sometimes dwarfing serialization wins for public reads. CPU and memory\nProtobuf serialization is efficient; big savings under high QPS and large payloads. JSON parsing is CPU-heavy; compression helps bandwidth but not CPU. Consider message compression (gzip, zstd) for both; measure the trade-offs. Bandwidth and egress costs\nProtobuf’s compactness lowers egress costs for internal service-to-service traffic. For public content, CDN caching with REST often saves the most. File upload/download\nREST: multipart/form-data for uploads; range requests for partial downloads; CDNs excel here. gRPC: typically send binary chunks via streaming or use a signed URL with REST/HTTP for the actual transfer; many teams pair gRPC control-plane with HTTP data-plane. N+1 and chattiness\ngRPC’s multiplexing and streaming can mitigate chattiness; batch requests with client streaming or design batch RPCs. REST should minimize round-trips with proper endpoints and query design; consider HTTP/2 to pipeline requests where supported. API Compatibility and Schema Evolution\nREST\nBackward compatibility is maintained via additive changes (new optional fields). Removing fields requires deprecation windows; beware breaking clients that assume fields. OpenAPI enables contract checks; use semantic versioning and changelogs. gRPC/Protobuf\nField numbers are forever; never reuse them after removal. Add fields as optional; reserve removed fields to prevent reuse. oneof for mutually exclusive fields; enums can add values, but default behavior must be safe. Use buf or similar tools to detect breaking changes. Migration and Hybrid Architectures\nCommon patterns\nPublic REST + Internal gRPC: expose REST/JSON to the outside, run gRPC inside the mesh; add a transcoding layer at the edge (Envoy/grpc-gateway). Dual-stack APIs: offer both REST and gRPC endpoints backed by a shared core service/component. Incremental migration: introduce gRPC alongside REST endpoints; route low-risk internal traffic first; keep REST stable for public clients. Strategies\nAPI gateway with JSON transcoding: keep clients on REST while services speak gRPC. Client libraries: provide gRPC SDKs for trusted partners while keeping REST for general users. Contract-first: define .proto as the source of truth, generate REST via annotations/transcoding rules. Pitfalls to avoid\nDivergent behaviors: ensure REST and gRPC paths enforce the same auth, validation, and rate limits. Error mismatch: map gRPC status codes to HTTP consistently. Shadow fields: keep schemas aligned; generate OpenAPI from proto where possible or vice versa. Best Practices and Common Pitfalls\nREST best practices\nEmbrace HTTP semantics: status codes, methods, caching. Keep resource modeling consistent; avoid verbs in URLs. Provide rich error bodies with machine-readable codes. Rate limit and provide Retry-After headers; use idempotency keys for unsafe retries. Write clear, versioned docs; publish OpenAPI specs. REST pitfalls\nOverloading POST for everything; ignoring caching; inconsistent pagination. Designing chatty endpoints that require many round-trips when a single purpose-built endpoint would suffice. gRPC best practices\nSet deadlines/timeouts in every client call; enforce server-side timeouts. Use interceptors/middleware for auth, logging, tracing. Define clear package versions (my.app.v1); use FieldMask for updates. Document services; generate client SDKs; lint with buf. Plan streaming semantics carefully; implement backpressure-aware processing. gRPC pitfalls\nExposing gRPC directly to browsers without grpc-web. Forgetting to propagate cancellations and deadlines. Reusing Protobuf field numbers or making breaking changes without coordination. Overusing fine-grained RPCs causing chattiness; batch where appropriate. Security Best Practices\nUse TLS everywhere; prefer mTLS in internal networks. Validate JWTs/auth tokens at the edge; enforce least-privilege scopes. Encrypt sensitive fields at rest and in transit; avoid logs leaking PII. For REST: implement CORS carefully; use same-site cookies and CSRF tokens if using cookies. For gRPC: use metadata for tokens; standardize on an authorization interceptor. Testing and Quality Gates\nREST\nUnit tests for handlers; contract tests using OpenAPI schemas. Integration tests with Postman/Newman or httpie; fuzzing for input validation. Load test with k6, Locust, or JMeter. gRPC\nUnit tests for services; golden tests for protobuf messages. grpcurl-based integration tests; ghz for load testing. Backward-compat checks with buf; reflection enabled in dev/test. Deployment Notes\nProxies Envoy is a strong default for gRPC and REST; supports retries, circuit breaking, observability, and JSON transcoding. NGINX and HAProxy can proxy gRPC and REST; verify HTTP/2 settings and keepalive. Kubernetes Use readiness/liveness probes; for gRPC consider gRPC health checking protocol. Service meshes add mTLS, routing, and telemetry with minimal code changes. Gateways Public edge often terminates TLS and handles rate limiting, WAF, and quotas. Ensure it’s gRPC-aware if you expose gRPC externally. Quotas and rate limiting Enforce centrally in the gateway/mesh; expose clear error codes (429 or ResourceExhausted). File Uploads and Large Messages\nREST Use multipart/form-data for uploads; presigned URLs with object storage to offload servers. Range and resumable uploads supported by many storage services. gRPC Prefer streaming chunks with size limits and checksums. For very large files, pair gRPC control with storage-backed HTTP uploads/downloads. Edge Scenarios\nPartial failures and circuit breaking Implement in the client and via the proxy/mesh. For gRPC, leverage service config/xDS; for REST, gateway policies and client libraries. Idempotency REST: idempotency keys for POST; PUT is idempotent by definition. gRPC: use request-idempotency tokens in request messages; configure retry policies only for idempotent methods. Ordering and delivery gRPC streams preserve ordering within a single stream. For cross-stream ordering, design explicit sequence semantics. REST doesn’t guarantee ordering across requests; design with version/sequence numbers. Decision Checklist: REST or gRPC? Choose REST if:\nYou’re building a public API for third-party developers. You need first-class browser and CDN support. You want to lean on HTTP caching and content negotiation. Your workloads are CRUD-heavy without complex streaming. Choose gRPC if:\nYou’re building internal microservices or a polyglot service mesh. You need low latency, high throughput, and compact payloads. You need bidirectional or client/server streaming. You want strict schemas with code generation and strong typing. Choose a hybrid if:\nYou need public developer reach and internal performance. You can place a transcoding gateway at the edge. You’re migrating without breaking existing clients. Practical Example: gRPC with REST Transcoding (Envoy)\nYou define .proto services and annotate methods with HTTP options (google.api.http) to describe how they map to REST routes. Envoy’s grpc-json-transcoder reads the proto descriptors and exposes REST endpoints that translate to gRPC under the hood. Benefits: single source of truth (proto), both REST and gRPC clients work, consistent business logic. Example proto with HTTP annotations\nimport \"google/api/annotations.proto\"; service UserService { rpc GetUser(GetUserRequest) returns (GetUserResponse) { option (google.api.http) = { get: \"/v1/users/{id}\" }; } rpc CreateUser(CreateUserRequest) returns (CreateUserResponse) { option (google.api.http) = { post: \"/v1/users\" body: \"*\" }; } } Then configure Envoy to load the proto descriptors and expose the REST paths. REST clients see JSON; backend services keep using gRPC+Protobuf.\nCommon Questions (FAQs)\nCan I use gRPC from the browser?\nNot directly. Use grpc-web with a proxy (Envoy or gRPC-Web server) that translates browser-friendly requests into gRPC. Is gRPC always faster than REST?\nIt often is for service-to-service traffic due to Protobuf and HTTP/2 multiplexing. But for public APIs, CDN caching and simpler infra can make REST perform better overall. Always measure in your context. Does gRPC support HTTP/3?\nSeveral language runtimes and proxies support gRPC over HTTP/3. Verify support in your stack and test end-to-end, especially with middleboxes. Can I use JSON with gRPC?\nYes, via transcoding/gateways or some libraries’ JSON marshalling. Protobuf remains the on-the-wire default for standard gRPC. What about GraphQL?\nGraphQL solves a different problem: flexible client-driven data fetching. It often complements REST and gRPC rather than replacing them, and typically runs over HTTP. How do I version gRPC APIs?\nUse package/service versioning (my.app.v1). Keep field additions backward-compatible; avoid removing/renumbering fields. How do I handle long-running operations?\nREST: return 202 Accepted and expose operation status endpoints; use webhooks or SSE for updates. gRPC: use server streaming to push progress, or return an operation ID and poll via unary RPC; deadlines and cancellation help control execution. Can I expose both REST and gRPC on the same service?\nYes. Either run two listeners or use a gateway/transcoder to bridge. Keep behavior consistent across both. Hands-on Performance Tips\nEnable compression (gzip or zstd) for large payloads on both REST and gRPC; set thresholds to avoid compressing tiny messages. Reuse connections; for gRPC, maintain channels; for REST, enable keep-alives and HTTP/2. Tune timeouts and retries conservatively to avoid retry storms; apply jittered exponential backoff. Validate and bound inputs; guard against huge JSON or Protobuf messages; set max message sizes. For streaming, implement flow control and backpressure-awareness. Choosing: A Simple Heuristic\nPublic web, partners, and browsers first? Start REST. Consider adding gRPC later for SDKs/internal services. Internal microservices, ML inference, or real-time streams? Start gRPC. Add REST via transcoding where needed. Mixed needs? Proto-first with Envoy transcoding offers a strong center of gravity. Summary REST and gRPC aren’t adversaries—they’re tools for different jobs. REST’s universality, human-friendliness, and HTTP semantics make it the default for public APIs and anything browser-facing. gRPC’s compact, strongly typed, streaming-friendly model shines for internal microservices, high-performance systems, and polyglot environments.\nYou don’t have to pick one forever. Many successful architectures use a hybrid: gRPC inside for speed and schema rigor, REST/JSON at the edge for reach and simplicity. Start with your constraints—clients, latency, bandwidth, tooling, and team expertise—then choose the protocol that reduces total system complexity.\nIf you remember just three things:\nREST maximizes reach and cacheability; gRPC maximizes efficiency and streaming. Strong schemas pay off: OpenAPI for REST, Protobuf for gRPC—automate codegen, docs, and breaking-change checks. Measure in production-like conditions; let data, not dogma, guide your choice. ","wordCount":"3394","inLanguage":"en","image":"http://localhost:1313/%3Cimage%20path/url%3E","datePublished":"2025-04-06T23:00:03Z","dateModified":"2025-04-06T23:00:03Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/post14/"},"publisher":{"@type":"Organization","name":"DeployAndRun","logo":{"@type":"ImageObject","url":"http://localhost:1313/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Home (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=http://localhost:1313/tags/ title=tags><span>tags</span></a></li><li><a href=http://localhost:1313/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">REST vs. gRPC Part2</h1><div class=post-description>REST vs. gRPC: Understanding the Differences and Choosing the Right Protocol</div><div class=post-meta><span title='2025-04-06 23:00:03 +0000 +0000'>April 6, 2025</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;3394 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/post14.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents></nav></div></details></div><div class=post-content><h1 id=rest-vs-grpc-the-pragmatic-developer-friendly-guide>REST vs gRPC: The Pragmatic, Developer-Friendly Guide<a hidden class=anchor aria-hidden=true href=#rest-vs-grpc-the-pragmatic-developer-friendly-guide>#</a></h1><p>TL;DR</p><ul><li>REST is universal, human-friendly, cacheable, and ideal for public APIs and browser clients. It uses HTTP semantics with resource-oriented design and JSON by default.</li><li>gRPC is fast, strongly typed, and streaming-friendly—great for internal microservices and low-latency mobile/IoT. It uses HTTP/2 (or HTTP/3 in some stacks) and Protocol Buffers (Protobuf).</li><li>Use REST for broad reach, compatibility, and simple CRUD; use gRPC for high-throughput, low-latency, streaming, or strongly typed interfaces across polyglot services.</li><li>Hybrid patterns—REST for public, gRPC internally—often deliver the best of both worlds.</li></ul><p>Contents</p><ul><li>What are REST and gRPC?</li><li>Mental Models: Resources vs RPC</li><li>Transports: HTTP/1.1, HTTP/2, HTTP/3</li><li>Data Formats: JSON vs Protobuf (and JSON with gRPC)</li><li>Streaming, Real-time, and Backpressure</li><li>API Design: URLs vs RPC methods, versioning, pagination</li><li>Errors, Retries, and Timeouts</li><li>Caching and CDNs</li><li>Security and Auth</li><li>Tooling and Developer Experience</li><li>Observability: Logs, Metrics, Traces</li><li>Platform Support: Browsers, Mobile, Cloud, and Meshes</li><li>Performance & Cost Considerations</li><li>Migration and Hybrid Architectures</li><li>Best Practices and Common Pitfalls</li><li>Decision Checklist</li><li>FAQs</li><li>Summary</li></ul><p>What are REST and gRPC?</p><ul><li>REST (Representational State Transfer) is an architectural style layered onto HTTP. You expose resources (users, orders, posts) with URLs and standard HTTP methods (GET, POST, PUT, PATCH, DELETE). Responses are typically JSON. REST’s superpower is universality: it works practically everywhere, especially on the web.</li><li>gRPC is an RPC framework created at Google. It uses Protocol Buffers (but can support other encodings) with an Interface Definition Language (IDL) to generate client and server code. It runs over HTTP/2 (and in several stacks HTTP/3) and supports streaming in all directions. Its superpower is efficiency, strong typing, and first-class streaming.</li></ul><p>Mental Models: Resources vs RPC</p><ul><li><p>REST: Resource-oriented</p><ul><li>Identify nouns/resources (e.g., /users/123/orders).</li><li>Use HTTP verbs to express actions (GET to read, POST to create).</li><li>Embrace HTTP semantics (status codes, caching, content negotiation).</li><li>Pros: self-descriptive, cache-friendly, easy for browsers, widely understood.</li><li>Trade-offs: mapping complex workflows or streaming can be awkward.</li></ul></li><li><p>gRPC: Procedure/method-oriented</p><ul><li>Define services and methods (UserService.GetUser, OrderService.CreateOrder).</li><li>Strongly typed requests/responses using Protobuf schemas.</li><li>Unary and streaming calls as first-class citizens.</li><li>Pros: compact, fast, codegen-powered DX, great for microservices and streaming.</li><li>Trade-offs: weaker browser-native support, tooling is different, caching/CDN less natural.</li></ul></li></ul><p>Transports: HTTP/1.1, HTTP/2, HTTP/3</p><ul><li><p>REST</p><ul><li>Typically HTTP/1.1, but also works over HTTP/2 and HTTP/3 transparently via standard web servers/CDNs.</li><li>Benefits from HTTP/2 multiplexing and header compression where available.</li><li>Easily goes through proxies, gateways, and CDNs.</li></ul></li><li><p>gRPC</p><ul><li>Standard gRPC uses HTTP/2 for multiplexed, bidirectional streams.</li><li>Many ecosystems now support gRPC over HTTP/3 (QUIC), improving head-of-line blocking and mobility; check your language/runtime’s current support.</li><li>Not natively supported by browsers due to streaming and header constraints; grpc-web bridges this gap via a proxy and HTTP/1.1/2 friendly semantics.</li></ul></li></ul><p>Data Formats: JSON vs Protobuf (and JSON with gRPC)</p><ul><li><p>REST payloads</p><ul><li>Commonly JSON; also XML, YAML, or binary for special cases.</li><li>Human-readable; excellent for debugging and public API docs.</li><li>Larger on-the-wire size vs Protobuf; more CPU to parse at scale.</li></ul></li><li><p>gRPC payloads</p><ul><li>Default is Protobuf: compact binary encoding, fast encoding/decoding.</li><li>Strong schemas with backward/forward-compatible design (field numbers, optional fields, oneof).</li><li>Unknown fields are usually ignored on parse—great for gradual rollout.</li></ul></li><li><p>JSON in gRPC?</p><ul><li>gRPC can be used with JSON via transcoding gateways (e.g., Envoy + grpc-json-transcoder or grpc-gateway). This lets you expose REST/JSON endpoints that internally call gRPC.</li><li>Some stacks support gRPC-JSON directly for ease of interop at the edge.</li></ul></li></ul><p>Streaming, Real-time, and Backpressure</p><ul><li>gRPC has first-class streaming:<ul><li>Unary: single request -> single response (most REST-like).</li><li>Server streaming: single request -> stream of responses (e.g., logs, events).</li><li>Client streaming: stream of requests -> single response (e.g., batch upload).</li><li>Bidirectional streaming: both sides stream concurrently (e.g., chat, telemetry, ML inference pipelines).</li></ul></li><li>REST equivalents:<ul><li>Server-sent events (SSE): server -> client stream over HTTP. Easy in browsers; unidirectional.</li><li>WebSockets: full-duplex channel over a single TCP; great for real-time, but not REST semantics and requires different infra and protocols.</li><li>Chunked transfer and long polling: workarounds, but not as clean as gRPC streaming.</li></ul></li></ul><p>Backpressure and flow control:</p><ul><li>gRPC/HTTP/2 provide built-in flow control and framing to handle backpressure more gracefully.</li><li>REST with SSE or WebSockets requires you to design your own flow control patterns and congestion/backpressure strategies.</li></ul><p>API Design: URLs vs RPC methods, versioning, pagination</p><ul><li><p>REST design tips</p><ul><li>Use plural nouns and resource hierarchies: GET /users/{id}/orders.</li><li>HTTP status codes (200, 201, 204, 400, 401, 403, 404, 409, 422, 429, 500).</li><li>Partial updates with PATCH and JSON Patch/JSON Merge Patch.</li><li>Versioning strategies: URI (/v1/), header-based, or default + backward-compatible evolution.</li><li>Pagination: limit/offset, or cursor/page_token. Cursor is preferred at scale.</li><li>Conditional requests: ETag/If-None-Match for concurrency and caching.</li><li>Filtering/sorting: query params (e.g., ?status=active&amp;sort=-created_at).</li></ul></li><li><p>gRPC design tips</p><ul><li>Services and RPCs should be business-action oriented but cohesive (UserService, OrderService).</li><li>Design request/response messages explicitly; include page_size and page_token in requests, and next_page_token in responses.</li><li>Use field numbers carefully; never reuse removed numbers; prefer additive changes (new optional fields).</li><li>Represent partial updates with FieldMask where applicable.</li><li>Consider error detail messages using google.rpc.Status and google.rpc.ErrorInfo for structured errors.</li><li>Versioning: package name and service name (my.app.v1) to separate new versions while allowing coexistence.</li></ul></li></ul><p>Code examples</p><p>REST (curl + Node.js/Express)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Create a user</span>
</span></span><span class=line><span class=cl>curl -X POST https://api.example.com/v1/users <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  -H <span class=s1>&#39;Content-Type: application/json&#39;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  -d <span class=s1>&#39;{&#34;email&#34;:&#34;dev@example.com&#34;,&#34;name&#34;:&#34;Doe&#34;}&#39;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// app.js (Express)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>express</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s1>&#39;express&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>app</span> <span class=o>=</span> <span class=nx>express</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=nx>app</span><span class=p>.</span><span class=nx>use</span><span class=p>(</span><span class=nx>express</span><span class=p>.</span><span class=nx>json</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>app</span><span class=p>.</span><span class=nx>get</span><span class=p>(</span><span class=s1>&#39;/v1/users/:id&#39;</span><span class=p>,</span> <span class=kr>async</span> <span class=p>(</span><span class=nx>req</span><span class=p>,</span> <span class=nx>res</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>user</span> <span class=o>=</span> <span class=kr>await</span> <span class=nx>db</span><span class=p>.</span><span class=nx>getUser</span><span class=p>(</span><span class=nx>req</span><span class=p>.</span><span class=nx>params</span><span class=p>.</span><span class=nx>id</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nx>user</span><span class=p>)</span> <span class=k>return</span> <span class=nx>res</span><span class=p>.</span><span class=nx>status</span><span class=p>(</span><span class=mi>404</span><span class=p>).</span><span class=nx>json</span><span class=p>({</span> <span class=nx>error</span><span class=o>:</span> <span class=s1>&#39;Not found&#39;</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>  <span class=nx>res</span><span class=p>.</span><span class=nx>json</span><span class=p>(</span><span class=nx>user</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>app</span><span class=p>.</span><span class=nx>post</span><span class=p>(</span><span class=s1>&#39;/v1/users&#39;</span><span class=p>,</span> <span class=kr>async</span> <span class=p>(</span><span class=nx>req</span><span class=p>,</span> <span class=nx>res</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>user</span> <span class=o>=</span> <span class=kr>await</span> <span class=nx>db</span><span class=p>.</span><span class=nx>createUser</span><span class=p>(</span><span class=nx>req</span><span class=p>.</span><span class=nx>body</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nx>res</span><span class=p>.</span><span class=nx>status</span><span class=p>(</span><span class=mi>201</span><span class=p>).</span><span class=nx>json</span><span class=p>(</span><span class=nx>user</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>app</span><span class=p>.</span><span class=nx>listen</span><span class=p>(</span><span class=mi>3000</span><span class=p>);</span>
</span></span></code></pre></div><p>gRPC (proto + Go server + grpcurl)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-proto data-lang=proto><span class=line><span class=cl><span class=c1>// user.proto
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>syntax</span> <span class=o>=</span> <span class=s>&#34;proto3&#34;</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=kn>package</span> <span class=nn>example</span><span class=o>.</span><span class=n>user.v1</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>option</span> <span class=n>go_package</span> <span class=o>=</span> <span class=s>&#34;example.com/user/gen;userv1&#34;</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=kd>service</span> <span class=n>UserService</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>  <span class=k>rpc</span> <span class=n>GetUser</span><span class=p>(</span><span class=n>GetUserRequest</span><span class=p>)</span> <span class=k>returns</span> <span class=p>(</span><span class=n>GetUserResponse</span><span class=p>)</span> <span class=p>{}</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>  <span class=k>rpc</span> <span class=n>CreateUser</span><span class=p>(</span><span class=n>CreateUserRequest</span><span class=p>)</span> <span class=k>returns</span> <span class=p>(</span><span class=n>CreateUserResponse</span><span class=p>)</span> <span class=p>{}</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>  <span class=k>rpc</span> <span class=n>StreamUsers</span><span class=p>(</span><span class=n>StreamUsersRequest</span><span class=p>)</span> <span class=k>returns</span> <span class=p>(</span><span class=n>stream</span> <span class=n>GetUserResponse</span><span class=p>)</span> <span class=p>{}</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=p>}</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=kd>message</span> <span class=nc>GetUserRequest</span> <span class=p>{</span> <span class=kt>string</span> <span class=n>id</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=p>}</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=kd>message</span> <span class=nc>GetUserResponse</span> <span class=p>{</span> <span class=kt>string</span> <span class=n>id</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=kt>string</span> <span class=n>email</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span> <span class=kt>string</span> <span class=n>name</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span> <span class=p>}</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=kd>message</span> <span class=nc>CreateUserRequest</span> <span class=p>{</span> <span class=kt>string</span> <span class=n>email</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=kt>string</span> <span class=n>name</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span> <span class=p>}</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=kd>message</span> <span class=nc>CreateUserResponse</span> <span class=p>{</span> <span class=kt>string</span> <span class=n>id</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=p>}</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=kd>message</span> <span class=nc>StreamUsersRequest</span> <span class=p>{</span> <span class=kt>int32</span> <span class=n>page_size</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=kt>string</span> <span class=n>page_token</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span> <span class=p>}</span><span class=err>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// server.go (Go gRPC)</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>userServer</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>userv1</span><span class=p>.</span><span class=nx>UnimplementedUserServiceServer</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>userServer</span><span class=p>)</span> <span class=nf>GetUser</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>req</span> <span class=o>*</span><span class=nx>userv1</span><span class=p>.</span><span class=nx>GetUserRequest</span><span class=p>)</span> <span class=p>(</span><span class=o>*</span><span class=nx>userv1</span><span class=p>.</span><span class=nx>GetUserResponse</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>u</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>dbGet</span><span class=p>(</span><span class=nx>req</span><span class=p>.</span><span class=nx>Id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nx>err</span> <span class=o>==</span> <span class=nx>sql</span><span class=p>.</span><span class=nx>ErrNoRows</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>status</span><span class=p>.</span><span class=nf>Error</span><span class=p>(</span><span class=nx>codes</span><span class=p>.</span><span class=nx>NotFound</span><span class=p>,</span> <span class=s>&#34;user not found&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>status</span><span class=p>.</span><span class=nf>Error</span><span class=p>(</span><span class=nx>codes</span><span class=p>.</span><span class=nx>Internal</span><span class=p>,</span> <span class=s>&#34;db error&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=o>&amp;</span><span class=nx>userv1</span><span class=p>.</span><span class=nx>GetUserResponse</span><span class=p>{</span><span class=nx>Id</span><span class=p>:</span> <span class=nx>u</span><span class=p>.</span><span class=nx>ID</span><span class=p>,</span> <span class=nx>Email</span><span class=p>:</span> <span class=nx>u</span><span class=p>.</span><span class=nx>Email</span><span class=p>,</span> <span class=nx>Name</span><span class=p>:</span> <span class=nx>u</span><span class=p>.</span><span class=nx>Name</span><span class=p>},</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Call gRPC with grpcurl (no client code needed)</span>
</span></span><span class=line><span class=cl>grpcurl -plaintext localhost:50051 example.user.v1.UserService/GetUser <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  -d <span class=s1>&#39;{&#34;id&#34;:&#34;123&#34;}&#39;</span>
</span></span></code></pre></div><p>Errors, Retries, and Timeouts</p><ul><li><p>REST error model</p><ul><li>HTTP status codes convey coarse categories. Include a JSON body with machine-readable codes and human-readable messages.</li><li>Typical mapping:<ul><li>400 Bad Request: validation errors</li><li>401 Unauthorized: auth required</li><li>403 Forbidden: not allowed</li><li>404 Not Found</li><li>409 Conflict: duplicate or state conflict</li><li>422 Unprocessable: semantic validation failed</li><li>429 Too Many Requests: rate limiting</li><li>500/502/503/504: server/network errors</li></ul></li><li>Retries: safe and idempotent methods (GET, HEAD) can be retried. POST requires idempotency keys if retried.</li></ul></li><li><p>gRPC error model</p><ul><li>gRPC status codes (codes.*) and rich error details through google.rpc.Status:<ul><li>InvalidArgument, NotFound, AlreadyExists, Unauthenticated, PermissionDenied</li><li>ResourceExhausted (rate limit), FailedPrecondition, Aborted (conflicts), OutOfRange</li><li>Unimplemented, Internal, Unavailable (retryable), DeadlineExceeded</li></ul></li><li>Retries: baked into gRPC service config and proxies (e.g., Envoy) with per-method policies and idempotency awareness.</li><li>Deadlines and cancellation are first-class: clients set deadlines; servers can observe ctx.Done() to stop work. Cancellation propagates over the wire.</li></ul></li></ul><p>Practical mapping between models (guidance):</p><ul><li>gRPC NotFound ↔ HTTP 404</li><li>InvalidArgument ↔ 400</li><li>AlreadyExists ↔ 409</li><li>ResourceExhausted ↔ 429</li><li>Unauthenticated ↔ 401; PermissionDenied ↔ 403</li><li>Unavailable ↔ 503; DeadlineExceeded ↔ 504</li><li>Internal ↔ 500; Unimplemented ↔ 501</li><li>Aborted/FailedPrecondition ↔ 409/400 depending on semantics</li></ul><p>Timeouts and deadlines:</p><ul><li>REST: use server-side timeouts and client request timeouts; communicate Retry-After when applicable.</li><li>gRPC: clients set explicit deadlines per call; servers should respect them and return DeadlineExceeded when exceeded.</li></ul><p>Caching and CDNs</p><ul><li><p>REST</p><ul><li>Strong out-of-the-box support: Cache-Control, ETag/If-None-Match, Last-Modified/If-Modified-Since, Vary.</li><li>CDNs and browsers understand HTTP semantics; static and dynamic GETs can be cached with fine-grained control.</li><li>Conditional requests reduce bandwidth and enable optimistic concurrency.</li></ul></li><li><p>gRPC</p><ul><li>Proxies generally don’t cache gRPC by default. You can add custom caching (e.g., via Envoy filters, application caches) but it requires deliberate design.</li><li>For public content and global distribution, REST + CDN is typically the simplest, cheapest path.</li></ul></li></ul><p>Security and Auth</p><ul><li><p>Transport security</p><ul><li>REST: HTTPS (TLS) is standard. mTLS is common in zero-trust/internal environments.</li><li>gRPC: also uses TLS; mTLS is common within service meshes. HTTP/2 uses ALPN to negotiate h2.</li></ul></li><li><p>AuthN/AuthZ</p><ul><li>REST: OAuth 2.0 and OpenID Connect for delegated access, JWT bearer tokens, API keys for simple cases. CORS for browser access control.</li><li>gRPC: send tokens via metadata (authorization: Bearer ) or dedicated headers. Integrates with OIDC/JWT, mTLS-based identity, and service meshes for policy (e.g., Istio, Linkerd).</li><li>Browser specifics: grpc-web uses standard HTTP requests under the hood, so CORS applies.</li></ul></li><li><p>CSRF/Clickjacking</p><ul><li>REST: use same-site cookies, CSRF tokens for cookie-backed auth.</li><li>gRPC: typically token-based headers; CSRF less of a concern when not using cookies.</li></ul></li></ul><p>Tooling and Developer Experience</p><ul><li><p>REST tools</p><ul><li>Specification: OpenAPI (Swagger), JSON Schema.</li><li>Docs/portals: Swagger UI, Redoc, Stoplight.</li><li>Testing: curl, httpie, Postman, Insomnia, Newman.</li><li>Mocking/contract tests: Prism, WireMock, Pact.</li><li>Client generation: openapi-generator, Swagger Codegen.</li></ul></li><li><p>gRPC tools</p><ul><li>Specification: .proto files (IDL). Code generation for clients/servers in many languages.</li><li>CLI: grpcurl, evans, ghz (load testing).</li><li>Ecosystem: Buf (lint/build/breaking-change checks), Prototool, protoc plugins.</li><li>Gateways: Envoy gRPC-JSON transcoder, grpc-gateway.</li><li>GUI clients: BloomRPC, Kreya, Insomnia gRPC.</li></ul></li></ul><p>Developer ergonomics</p><ul><li>REST: zero-code clients (curl) and easy browser testing. JSON is human-readable.</li><li>gRPC: strong typing, auto-generated stubs, streaming APIs, better for polyglot microservices. Requires proto discipline and tooling setup.</li></ul><p>Observability: Logs, Metrics, Traces</p><ul><li><p>REST</p><ul><li>Use structured logs (method, path, status, duration, request-id).</li><li>Metrics: request rate, latency, error rates, by endpoint and verb.</li><li>Tracing: OpenTelemetry instrumentation, propagate traceparent header (W3C Trace Context).</li><li>Correlation IDs: X-Request-ID or trace context headers.</li></ul></li><li><p>gRPC</p><ul><li>Logs: include method name (Service/Method), peer info, status codes.</li><li>Metrics: per-method latency, message counts (for streams).</li><li>Tracing: OpenTelemetry with gRPC interceptors automatically capturing spans. Propagate metadata (e.g., grpc-trace-bin, or W3C headers where supported).</li><li>Deadlines, retries, and cancellations show up in spans—great for troubleshooting.</li></ul></li></ul><p>Platform Support: Browsers, Mobile, Cloud, and Meshes</p><ul><li><p>Browsers</p><ul><li>REST: native. CORS handled by server.</li><li>gRPC: not natively supported due to HTTP/2 and binary framing; use grpc-web via a proxy (Envoy, gRPC-Web) to translate between browser-friendly HTTP and backend gRPC.</li></ul></li><li><p>Mobile</p><ul><li>Both REST and gRPC work. gRPC’s smaller payloads and multiplexing can save battery and data; REST may be simpler if you also need caching/CDN and offline sync with HTTP caches.</li></ul></li><li><p>Cloud load balancers and gateways</p><ul><li>REST: works with any gateway/CDN (CloudFront, Cloudflare, Fastly, API Gateway).</li><li>gRPC: widely supported by modern L7 proxies (Envoy, NGINX, HAProxy) and managed LBs on major clouds. Some API gateways now forward gRPC and even support transcoding. Verify feature parity (e.g., retries, H/2 keepalives, connection limits).</li></ul></li><li><p>Service meshes</p><ul><li>Both REST and gRPC benefit. gRPC + mesh (e.g., Istio/Envoy) unlocks rich policies (mTLS, retries, timeouts) and telemetry with minimal app code.</li></ul></li></ul><p>Performance & Cost Considerations</p><ul><li><p>Latency and throughput</p><ul><li>gRPC with Protobuf is typically faster to parse and smaller over the wire than REST+JSON, especially at scale and with chatty internal services.</li><li>HTTP/2 multiplexing reduces head-of-line blocking and connection overhead.</li><li>With HTTP/3 (QUIC), gRPC can further reduce tail latency on lossy networks.</li><li>REST benefits from CDNs and caching, sometimes dwarfing serialization wins for public reads.</li></ul></li><li><p>CPU and memory</p><ul><li>Protobuf serialization is efficient; big savings under high QPS and large payloads.</li><li>JSON parsing is CPU-heavy; compression helps bandwidth but not CPU.</li><li>Consider message compression (gzip, zstd) for both; measure the trade-offs.</li></ul></li><li><p>Bandwidth and egress costs</p><ul><li>Protobuf’s compactness lowers egress costs for internal service-to-service traffic.</li><li>For public content, CDN caching with REST often saves the most.</li></ul></li><li><p>File upload/download</p><ul><li>REST: multipart/form-data for uploads; range requests for partial downloads; CDNs excel here.</li><li>gRPC: typically send binary chunks via streaming or use a signed URL with REST/HTTP for the actual transfer; many teams pair gRPC control-plane with HTTP data-plane.</li></ul></li><li><p>N+1 and chattiness</p><ul><li>gRPC’s multiplexing and streaming can mitigate chattiness; batch requests with client streaming or design batch RPCs.</li><li>REST should minimize round-trips with proper endpoints and query design; consider HTTP/2 to pipeline requests where supported.</li></ul></li></ul><p>API Compatibility and Schema Evolution</p><ul><li><p>REST</p><ul><li>Backward compatibility is maintained via additive changes (new optional fields).</li><li>Removing fields requires deprecation windows; beware breaking clients that assume fields.</li><li>OpenAPI enables contract checks; use semantic versioning and changelogs.</li></ul></li><li><p>gRPC/Protobuf</p><ul><li>Field numbers are forever; never reuse them after removal.</li><li>Add fields as optional; reserve removed fields to prevent reuse.</li><li>oneof for mutually exclusive fields; enums can add values, but default behavior must be safe.</li><li>Use buf or similar tools to detect breaking changes.</li></ul></li></ul><p>Migration and Hybrid Architectures</p><ul><li><p>Common patterns</p><ul><li>Public REST + Internal gRPC: expose REST/JSON to the outside, run gRPC inside the mesh; add a transcoding layer at the edge (Envoy/grpc-gateway).</li><li>Dual-stack APIs: offer both REST and gRPC endpoints backed by a shared core service/component.</li><li>Incremental migration: introduce gRPC alongside REST endpoints; route low-risk internal traffic first; keep REST stable for public clients.</li></ul></li><li><p>Strategies</p><ul><li>API gateway with JSON transcoding: keep clients on REST while services speak gRPC.</li><li>Client libraries: provide gRPC SDKs for trusted partners while keeping REST for general users.</li><li>Contract-first: define .proto as the source of truth, generate REST via annotations/transcoding rules.</li></ul></li><li><p>Pitfalls to avoid</p><ul><li>Divergent behaviors: ensure REST and gRPC paths enforce the same auth, validation, and rate limits.</li><li>Error mismatch: map gRPC status codes to HTTP consistently.</li><li>Shadow fields: keep schemas aligned; generate OpenAPI from proto where possible or vice versa.</li></ul></li></ul><p>Best Practices and Common Pitfalls</p><ul><li><p>REST best practices</p><ul><li>Embrace HTTP semantics: status codes, methods, caching.</li><li>Keep resource modeling consistent; avoid verbs in URLs.</li><li>Provide rich error bodies with machine-readable codes.</li><li>Rate limit and provide Retry-After headers; use idempotency keys for unsafe retries.</li><li>Write clear, versioned docs; publish OpenAPI specs.</li></ul></li><li><p>REST pitfalls</p><ul><li>Overloading POST for everything; ignoring caching; inconsistent pagination.</li><li>Designing chatty endpoints that require many round-trips when a single purpose-built endpoint would suffice.</li></ul></li><li><p>gRPC best practices</p><ul><li>Set deadlines/timeouts in every client call; enforce server-side timeouts.</li><li>Use interceptors/middleware for auth, logging, tracing.</li><li>Define clear package versions (my.app.v1); use FieldMask for updates.</li><li>Document services; generate client SDKs; lint with buf.</li><li>Plan streaming semantics carefully; implement backpressure-aware processing.</li></ul></li><li><p>gRPC pitfalls</p><ul><li>Exposing gRPC directly to browsers without grpc-web.</li><li>Forgetting to propagate cancellations and deadlines.</li><li>Reusing Protobuf field numbers or making breaking changes without coordination.</li><li>Overusing fine-grained RPCs causing chattiness; batch where appropriate.</li></ul></li></ul><p>Security Best Practices</p><ul><li>Use TLS everywhere; prefer mTLS in internal networks.</li><li>Validate JWTs/auth tokens at the edge; enforce least-privilege scopes.</li><li>Encrypt sensitive fields at rest and in transit; avoid logs leaking PII.</li><li>For REST: implement CORS carefully; use same-site cookies and CSRF tokens if using cookies.</li><li>For gRPC: use metadata for tokens; standardize on an authorization interceptor.</li></ul><p>Testing and Quality Gates</p><ul><li><p>REST</p><ul><li>Unit tests for handlers; contract tests using OpenAPI schemas.</li><li>Integration tests with Postman/Newman or httpie; fuzzing for input validation.</li><li>Load test with k6, Locust, or JMeter.</li></ul></li><li><p>gRPC</p><ul><li>Unit tests for services; golden tests for protobuf messages.</li><li>grpcurl-based integration tests; ghz for load testing.</li><li>Backward-compat checks with buf; reflection enabled in dev/test.</li></ul></li></ul><p>Deployment Notes</p><ul><li>Proxies<ul><li>Envoy is a strong default for gRPC and REST; supports retries, circuit breaking, observability, and JSON transcoding.</li><li>NGINX and HAProxy can proxy gRPC and REST; verify HTTP/2 settings and keepalive.</li></ul></li><li>Kubernetes<ul><li>Use readiness/liveness probes; for gRPC consider gRPC health checking protocol.</li><li>Service meshes add mTLS, routing, and telemetry with minimal code changes.</li></ul></li><li>Gateways<ul><li>Public edge often terminates TLS and handles rate limiting, WAF, and quotas. Ensure it’s gRPC-aware if you expose gRPC externally.</li></ul></li><li>Quotas and rate limiting<ul><li>Enforce centrally in the gateway/mesh; expose clear error codes (429 or ResourceExhausted).</li></ul></li></ul><p>File Uploads and Large Messages</p><ul><li>REST<ul><li>Use multipart/form-data for uploads; presigned URLs with object storage to offload servers.</li><li>Range and resumable uploads supported by many storage services.</li></ul></li><li>gRPC<ul><li>Prefer streaming chunks with size limits and checksums.</li><li>For very large files, pair gRPC control with storage-backed HTTP uploads/downloads.</li></ul></li></ul><p>Edge Scenarios</p><ul><li>Partial failures and circuit breaking<ul><li>Implement in the client and via the proxy/mesh. For gRPC, leverage service config/xDS; for REST, gateway policies and client libraries.</li></ul></li><li>Idempotency<ul><li>REST: idempotency keys for POST; PUT is idempotent by definition.</li><li>gRPC: use request-idempotency tokens in request messages; configure retry policies only for idempotent methods.</li></ul></li><li>Ordering and delivery<ul><li>gRPC streams preserve ordering within a single stream. For cross-stream ordering, design explicit sequence semantics.</li><li>REST doesn’t guarantee ordering across requests; design with version/sequence numbers.</li></ul></li></ul><p>Decision Checklist: REST or gRPC?
Choose REST if:</p><ul><li>You’re building a public API for third-party developers.</li><li>You need first-class browser and CDN support.</li><li>You want to lean on HTTP caching and content negotiation.</li><li>Your workloads are CRUD-heavy without complex streaming.</li></ul><p>Choose gRPC if:</p><ul><li>You’re building internal microservices or a polyglot service mesh.</li><li>You need low latency, high throughput, and compact payloads.</li><li>You need bidirectional or client/server streaming.</li><li>You want strict schemas with code generation and strong typing.</li></ul><p>Choose a hybrid if:</p><ul><li>You need public developer reach and internal performance.</li><li>You can place a transcoding gateway at the edge.</li><li>You’re migrating without breaking existing clients.</li></ul><p>Practical Example: gRPC with REST Transcoding (Envoy)</p><ul><li>You define .proto services and annotate methods with HTTP options (google.api.http) to describe how they map to REST routes.</li><li>Envoy’s grpc-json-transcoder reads the proto descriptors and exposes REST endpoints that translate to gRPC under the hood.</li><li>Benefits: single source of truth (proto), both REST and gRPC clients work, consistent business logic.</li></ul><p>Example proto with HTTP annotations</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-proto data-lang=proto><span class=line><span class=cl><span class=k>import</span> <span class=s>&#34;google/api/annotations.proto&#34;</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=kd>service</span> <span class=n>UserService</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>  <span class=k>rpc</span> <span class=n>GetUser</span><span class=p>(</span><span class=n>GetUserRequest</span><span class=p>)</span> <span class=k>returns</span> <span class=p>(</span><span class=n>GetUserResponse</span><span class=p>)</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>    <span class=k>option</span> <span class=p>(</span><span class=n>google.api.http</span><span class=p>)</span> <span class=o>=</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>      <span class=n>get</span><span class=o>:</span> <span class=s>&#34;/v1/users/{id}&#34;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>    <span class=p>};</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>  <span class=p>}</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>  <span class=k>rpc</span> <span class=n>CreateUser</span><span class=p>(</span><span class=n>CreateUserRequest</span><span class=p>)</span> <span class=k>returns</span> <span class=p>(</span><span class=n>CreateUserResponse</span><span class=p>)</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>    <span class=k>option</span> <span class=p>(</span><span class=n>google.api.http</span><span class=p>)</span> <span class=o>=</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>      <span class=n>post</span><span class=o>:</span> <span class=s>&#34;/v1/users&#34;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>      <span class=n>body</span><span class=o>:</span> <span class=s>&#34;*&#34;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>    <span class=p>};</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>  <span class=p>}</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=p>}</span><span class=err>
</span></span></span></code></pre></div><p>Then configure Envoy to load the proto descriptors and expose the REST paths. REST clients see JSON; backend services keep using gRPC+Protobuf.</p><p>Common Questions (FAQs)</p><ul><li><p>Can I use gRPC from the browser?</p><ul><li>Not directly. Use grpc-web with a proxy (Envoy or gRPC-Web server) that translates browser-friendly requests into gRPC.</li></ul></li><li><p>Is gRPC always faster than REST?</p><ul><li>It often is for service-to-service traffic due to Protobuf and HTTP/2 multiplexing. But for public APIs, CDN caching and simpler infra can make REST perform better overall. Always measure in your context.</li></ul></li><li><p>Does gRPC support HTTP/3?</p><ul><li>Several language runtimes and proxies support gRPC over HTTP/3. Verify support in your stack and test end-to-end, especially with middleboxes.</li></ul></li><li><p>Can I use JSON with gRPC?</p><ul><li>Yes, via transcoding/gateways or some libraries’ JSON marshalling. Protobuf remains the on-the-wire default for standard gRPC.</li></ul></li><li><p>What about GraphQL?</p><ul><li>GraphQL solves a different problem: flexible client-driven data fetching. It often complements REST and gRPC rather than replacing them, and typically runs over HTTP.</li></ul></li><li><p>How do I version gRPC APIs?</p><ul><li>Use package/service versioning (my.app.v1). Keep field additions backward-compatible; avoid removing/renumbering fields.</li></ul></li><li><p>How do I handle long-running operations?</p><ul><li>REST: return 202 Accepted and expose operation status endpoints; use webhooks or SSE for updates.</li><li>gRPC: use server streaming to push progress, or return an operation ID and poll via unary RPC; deadlines and cancellation help control execution.</li></ul></li><li><p>Can I expose both REST and gRPC on the same service?</p><ul><li>Yes. Either run two listeners or use a gateway/transcoder to bridge. Keep behavior consistent across both.</li></ul></li></ul><p>Hands-on Performance Tips</p><ul><li>Enable compression (gzip or zstd) for large payloads on both REST and gRPC; set thresholds to avoid compressing tiny messages.</li><li>Reuse connections; for gRPC, maintain channels; for REST, enable keep-alives and HTTP/2.</li><li>Tune timeouts and retries conservatively to avoid retry storms; apply jittered exponential backoff.</li><li>Validate and bound inputs; guard against huge JSON or Protobuf messages; set max message sizes.</li><li>For streaming, implement flow control and backpressure-awareness.</li></ul><p>Choosing: A Simple Heuristic</p><ul><li>Public web, partners, and browsers first? Start REST. Consider adding gRPC later for SDKs/internal services.</li><li>Internal microservices, ML inference, or real-time streams? Start gRPC. Add REST via transcoding where needed.</li><li>Mixed needs? Proto-first with Envoy transcoding offers a strong center of gravity.</li></ul><p>Summary
REST and gRPC aren’t adversaries—they’re tools for different jobs. REST’s universality, human-friendliness, and HTTP semantics make it the default for public APIs and anything browser-facing. gRPC’s compact, strongly typed, streaming-friendly model shines for internal microservices, high-performance systems, and polyglot environments.</p><p>You don’t have to pick one forever. Many successful architectures use a hybrid: gRPC inside for speed and schema rigor, REST/JSON at the edge for reach and simplicity. Start with your constraints—clients, latency, bandwidth, tooling, and team expertise—then choose the protocol that reduces total system complexity.</p><p>If you remember just three things:</p><ol><li>REST maximizes reach and cacheability; gRPC maximizes efficiency and streaming.</li><li>Strong schemas pay off: OpenAPI for REST, Protobuf for gRPC—automate codegen, docs, and breaking-change checks.</li><li>Measure in production-like conditions; let data, not dogma, guide your choice.</li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/rest/>REST</a></li><li><a href=http://localhost:1313/tags/grpc/>GRPC</a></li></ul><nav class=paginav><a class=next href=http://localhost:1313/posts/post13/><span class=title>Next »</span><br><span>REST vs. gRPC</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share REST vs. gRPC Part2 on x" href="https://x.com/intent/tweet/?text=REST%20vs.%20gRPC%20Part2&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fpost14%2f&amp;hashtags=REST%2cgRPC"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share REST vs. gRPC Part2 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fpost14%2f&amp;title=REST%20vs.%20gRPC%20Part2&amp;summary=REST%20vs.%20gRPC%20Part2&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fpost14%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share REST vs. gRPC Part2 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fpost14%2f&title=REST%20vs.%20gRPC%20Part2"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share REST vs. gRPC Part2 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fpost14%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share REST vs. gRPC Part2 on whatsapp" href="https://api.whatsapp.com/send?text=REST%20vs.%20gRPC%20Part2%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fpost14%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share REST vs. gRPC Part2 on telegram" href="https://telegram.me/share/url?text=REST%20vs.%20gRPC%20Part2&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fpost14%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share REST vs. gRPC Part2 on ycombinator" href="https://news.ycombinator.com/submitlink?t=REST%20vs.%20gRPC%20Part2&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fpost14%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg></a><footer class=footer><div class=footer__inner><div class=copyright>© 2025 Sérgio Soares · Built with care and open source</div></div></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>